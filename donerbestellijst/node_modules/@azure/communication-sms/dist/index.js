'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var communicationCommon = require('@azure/communication-common');
var coreAuth = require('@azure/core-auth');
var coreClient = require('@azure/core-client');
var coreTracing = require('@azure/core-tracing');
var tslib = require('tslib');
var uuid = require('uuid');
var logger$1 = require('@azure/logger');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.Communication",
    packageName: "@azure/communication-sms",
    packageVersion: "1.1.0"
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SendMessageRequest = {
    type: {
        name: "Composite",
        className: "SendMessageRequest",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "String"
                }
            },
            smsRecipients: {
                serializedName: "smsRecipients",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SmsRecipient"
                        }
                    }
                }
            },
            message: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            smsSendOptions: {
                serializedName: "smsSendOptions",
                type: {
                    name: "Composite",
                    className: "SmsSendOptions"
                }
            }
        }
    }
};
const SmsRecipient = {
    type: {
        name: "Composite",
        className: "SmsRecipient",
        modelProperties: {
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "String"
                }
            },
            repeatabilityRequestId: {
                serializedName: "repeatabilityRequestId",
                type: {
                    name: "String"
                }
            },
            repeatabilityFirstSent: {
                serializedName: "repeatabilityFirstSent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SmsSendOptions = {
    type: {
        name: "Composite",
        className: "SmsSendOptions",
        modelProperties: {
            enableDeliveryReport: {
                serializedName: "enableDeliveryReport",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SmsSendResponse = {
    type: {
        name: "Composite",
        className: "SmsSendResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SmsSendResponseItem"
                        }
                    }
                }
            }
        }
    }
};
const SmsSendResponseItem = {
    type: {
        name: "Composite",
        className: "SmsSendResponseItem",
        modelProperties: {
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "String"
                }
            },
            messageId: {
                serializedName: "messageId",
                type: {
                    name: "String"
                }
            },
            httpStatusCode: {
                serializedName: "httpStatusCode",
                required: true,
                type: {
                    name: "Number"
                }
            },
            repeatabilityResult: {
                serializedName: "repeatabilityResult",
                type: {
                    name: "String"
                }
            },
            successful: {
                serializedName: "successful",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SendMessageRequest: SendMessageRequest,
    SmsRecipient: SmsRecipient,
    SmsSendOptions: SmsSendOptions,
    SmsSendResponse: SmsSendResponse,
    SmsSendResponseItem: SmsSendResponseItem
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const sendMessageRequest = {
    parameterPath: "sendMessageRequest",
    mapper: SendMessageRequest
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-03-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Sms operations. */
class SmsImpl {
    /**
     * Initialize a new instance of the class Sms class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Sends a SMS message from a phone number that belongs to the authenticated account.
     * @param sendMessageRequest Represents the body of the send message request.
     * @param options The options parameters.
     */
    async send(sendMessageRequest, options) {
        return tracingClient.withSpan("SmsApiClient.send", options !== null && options !== void 0 ? options : {}, async (options) => {
            return this.client.sendOperationRequest({ sendMessageRequest, options }, sendOperationSpec);
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const sendOperationSpec = {
    path: "/sms",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: SmsSendResponse
        }
    },
    requestBody: sendMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SmsApiClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the SmsApiClient class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-communication-sms/1.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-03-07";
        this.sms = new SmsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const extractOperationOptions = (obj) => {
    const { abortSignal, onResponse, requestOptions, serializerOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "onResponse", "requestOptions", "serializerOptions", "tracingOptions"]);
    return {
        operationOptions: {
            abortSignal,
            requestOptions,
            tracingOptions,
        },
        restOptions,
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// This is used as a workaround to be able to stub generateUuid
// during testing.
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 * @internal
 */
class Uuid {
    static generateUuid() {
        return uuid.v4();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function generateSendMessageRequest(smsRequest, options = {}) {
    var _a, _b;
    ({
        enableDeliveryReport: (_a = options.enableDeliveryReport) !== null && _a !== void 0 ? _a : false,
    });
    if (options.tag) {
        options.tag;
    }
    return {
        from: smsRequest.from,
        smsRecipients: smsRequest.to.map((phoneNumberStr) => {
            return {
                to: phoneNumberStr,
                repeatabilityFirstSent: new Date(Date.now()).toUTCString(),
                repeatabilityRequestId: Uuid.generateUuid(),
            };
        }),
        message: smsRequest.message,
        smsSendOptions: Object.assign({ enableDeliveryReport: (_b = options.enableDeliveryReport) !== null && _b !== void 0 ? _b : false }, (options.tag && { tag: options.tag })),
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-sms");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference lib="esnext.asynciterable" />
/**
 * Checks whether the type of a value is SmsClientOptions or not.
 *
 * @param options - The value being checked.
 */
const isSmsClientOptions = (options) => !!options && !coreAuth.isTokenCredential(options) && !communicationCommon.isKeyCredential(options);
/**
 * A SmsClient represents a Client to the Azure Communication Sms service allowing you
 * to send SMS messages.
 */
class SmsClient {
    constructor(connectionStringOrUrl, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrUrl, credentialOrOptions);
        const options = isSmsClientOptions(credentialOrOptions) ? credentialOrOptions : maybeOptions;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.api = new SmsApiClient(url, internalPipelineOptions);
        this.api.pipeline.addPolicy(authPolicy);
    }
    /**
     * Sends an SMS from a phone number that is acquired by the authenticated account, to another phone number.
     *
     * @param sendRequest - Provides the sender's and recipient's phone numbers, and the contents of the message
     * @param options - Additional request options
     */
    async send(sendRequest, options = { enableDeliveryReport: false }) {
        const { operationOptions, restOptions } = extractOperationOptions(options);
        return tracingClient.withSpan("SmsClient-Send", operationOptions, async (updatedOptions) => {
            const response = await this.api.sms.send(generateSendMessageRequest(sendRequest, restOptions), updatedOptions);
            return response.value;
        });
    }
}

exports.SmsClient = SmsClient;
//# sourceMappingURL=index.js.map
